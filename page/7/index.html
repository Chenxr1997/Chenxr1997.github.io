<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Chenxr&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Chenxr&#39;s blogs">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chenxr&#39;s blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/">





  <title>Chenxr's blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenxr's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-数据结构/" itemprop="url">计算机科学与工程-数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:41:04+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1>线性表</h1>
<p>线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列</p>
<p>实现线性表的方式一般有两种</p>
<ul>
<li>一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素</li>
<li>另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）</li>
</ul>
<h2 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h2>
<p>数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。虽然数组一旦创建之后，它的大小就无法改变了</p>
<p>当数组不能再存储线性表中的新元素时，可以创建一个新的大的数组来替换当前数组。这样就可以使用数组实现动态的数据结构</p>
<h3 id="操作"><a class="header-anchor" href="#操作">¶</a>操作</h3>
<p>创建数组</p>
<p>插入元素</p>
<p>删除元素</p>
<p>修改元素</p>
<p>遍历元素</p>
<h3 id="特点"><a class="header-anchor" href="#特点">¶</a>特点</h3>
<p>优点</p>
<p>缺点</p>
<p>使用场景</p>
<h2 id="链表"><a class="header-anchor" href="#链表">¶</a>链表</h2>
<h3 id="单链表"><a class="header-anchor" href="#单链表">¶</a>单链表</h3>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，这些节点不必在内存中相连。每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高</p>
<p><img src="/2019/03/08/计算机科学与工程-数据结构/image-20190814192609702.png" alt="image-20190814192609702"></p>
<h4 id="操作-v2"><a class="header-anchor" href="#操作-v2">¶</a>操作</h4>
<p>初始化链表</p>
<p>加入节点</p>
<p>删除节点</p>
<p>修改节点</p>
<p>顺序遍历链表</p>
<p>倒序遍历链表</p>
<p>单链表反转</p>
<h3 id="双向链表"><a class="header-anchor" href="#双向链表">¶</a>双向链表</h3>
<p>主要是节点中包含两个指针部分，一个指向前驱元，一个指向后继元</p>
<h3 id="循环链表"><a class="header-anchor" href="#循环链表">¶</a>循环链表</h3>
<p>最后一个节点指向第一个节点</p>
<h2 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h2>
<p>栈是比较特殊的线性表，访问、插入和删除元素只能在栈顶进行，栈有时又叫作LIFO(Last In First Out)表，即后进先出</p>
<h3 id="操作-v3"><a class="header-anchor" href="#操作-v3">¶</a>操作</h3>
<p>push(进栈，相当于插入)</p>
<p>pop(出栈，相当于删除最后一个元素)</p>
<h2 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h2>
<p>队列是比较特殊的线性表，对于队列来说，只允许在表的前端/队头（front）进行删除操作，而在表的后端/队尾（rear）进行插入操作</p>
<p><img src="/2019/03/08/计算机科学与工程-数据结构/image-20190814194101207.png" alt="image-20190814194101207"></p>
<h3 id="操作-v4"><a class="header-anchor" href="#操作-v4">¶</a>操作</h3>
<p>入队</p>
<p>出队</p>
<h1>树</h1>
<h2 id="二叉树"><a class="header-anchor" href="#二叉树">¶</a>二叉树</h2>
<h3 id="完全二叉树"><a class="header-anchor" href="#完全二叉树">¶</a>完全二叉树</h3>
<h3 id="二叉搜索树"><a class="header-anchor" href="#二叉搜索树">¶</a>二叉搜索树</h3>
<h2 id="b树"><a class="header-anchor" href="#b树">¶</a>B树</h2>
<h3 id="b-树"><a class="header-anchor" href="#b-树">¶</a>B+树</h3>
<h2 id="红黑树"><a class="header-anchor" href="#红黑树">¶</a>红黑树</h2>
<h2 id="van-emde-boas树"><a class="header-anchor" href="#van-emde-boas树">¶</a>van Emde Boas树</h2>
<h1>哈希表/散列表</h1>
<p>解决冲突的办法</p>
<p>1.线性探查法（linear probing）</p>
<p>2.平方探查法（quadratic probing）</p>
<p>3.链地址法</p>
<p>hash冲突解决方法<br>
关键字值不同的元素可能会映象到哈希表的同一地址上就会发生哈希冲突。解决办法：</p>
<p>1）开放定址法：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。</p>
<p>2） 再哈希法：同时构造多个不同的哈希函数。</p>
<p>3）链地址法：将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p>4）建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<h1>图</h1>
<h1>矩阵</h1>
<p>稀疏矩阵，三角矩阵</p>
<h1>堆</h1>
<p>堆，斐波那契堆</p>
<h1>不相交集合</h1>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/shell/" itemprop="url">shell</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:45+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1>文件系统</h1>
<h2 id="pwd-查看当前目录路径"><a class="header-anchor" href="#pwd-查看当前目录路径">¶</a>pwd 查看当前目录路径</h2>
<h2 id="ls-显示目录内容"><a class="header-anchor" href="#ls-显示目录内容">¶</a>ls 显示目录内容</h2>
<h2 id="cd-目录跳转"><a class="header-anchor" href="#cd-目录跳转">¶</a>cd 目录跳转</h2>
<h2 id="mkdir-创建文件夹"><a class="header-anchor" href="#mkdir-创建文件夹">¶</a>mkdir 创建文件夹</h2>
<h2 id="touch-创建文件"><a class="header-anchor" href="#touch-创建文件">¶</a>touch 创建文件</h2>
<h2 id="rm-删除文件"><a class="header-anchor" href="#rm-删除文件">¶</a>rm 删除文件</h2>
<h2 id="mv-移动文件"><a class="header-anchor" href="#mv-移动文件">¶</a>mv 移动文件</h2>
<h2 id="cp-拷贝文件"><a class="header-anchor" href="#cp-拷贝文件">¶</a>cp 拷贝文件</h2>
<h2 id="cat-输出文件内容"><a class="header-anchor" href="#cat-输出文件内容">¶</a>cat 输出文件内容</h2>
<h2 id="chmod-给文件的属主分配权限"><a class="header-anchor" href="#chmod-给文件的属主分配权限">¶</a>chmod 给文件的属主分配权限</h2>
<h1>进程</h1>
<h2 id="ps-查询进程"><a class="header-anchor" href="#ps-查询进程">¶</a>ps 查询进程</h2>
<h2 id="kill-杀死进程"><a class="header-anchor" href="#kill-杀死进程">¶</a>kill 杀死进程</h2>
<h2 id="lsof-查看端口"><a class="header-anchor" href="#lsof-查看端口">¶</a>lsof 查看端口</h2>
<h2 id="top-持续监控进程-系统整体信息"><a class="header-anchor" href="#top-持续监控进程-系统整体信息">¶</a>top 持续监控进程/系统整体信息</h2>
<h1>网络</h1>
<h2 id="curl-下载命令"><a class="header-anchor" href="#curl-下载命令">¶</a>curl 下载命令</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o</span><br></pre></td></tr></table></figure>
<h2 id="scp-终端传输命令"><a class="header-anchor" href="#scp-终端传输命令">¶</a>scp 终端传输命令</h2>
<p>使用ssh连接和加密方式</p>
<h2 id="netstat-查看网络信息"><a class="header-anchor" href="#netstat-查看网络信息">¶</a>netstat 查看网络信息</h2>
<h1>vim</h1>
<h1>其他</h1>
<h2 id="clear-清除屏幕内容"><a class="header-anchor" href="#clear-清除屏幕内容">¶</a>clear 清除屏幕内容</h2>
<h2 id="history-查看命令历史"><a class="header-anchor" href="#history-查看命令历史">¶</a>history 查看命令历史</h2>
<h2 id="echo-输出命令"><a class="header-anchor" href="#echo-输出命令">¶</a>echo 输出命令</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/算法刷题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/算法刷题/" itemprop="url">算法刷题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:45+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LeetCode-1 Two Sum(Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice)</p>
<p>两遍哈希，一遍哈希</p>
<p>LeetCode-2. Add Two Numbers（You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.）</p>
<p>初等数学遍历相加</p>
<p>LeetCode-3. Longest Substring Without Repeating Characters（Given a string, find the length of the longest substring without repeating characters）</p>
<p>滑动窗口</p>
<p>区分subsequence和substring</p>
<p>LeetCode-4. Median of Two Sorted Arrays（There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n))）</p>
<p>递归</p>
<p>LeetCode-</p>
<p>LeetCode-46. Permutations（Given a collection of distinct integers, return all possible permutations）</p>
<p>递归</p>
<p>LeetCode:47. Permutations II</p>
<p>递归</p>
<p>LeetCode 50.Pow(x, n)</p>
<p>分治</p>
<p>Leetcode 69. Sqrt(x)</p>
<p>二分法</p>
<p>牛顿逼近</p>
<p>leetCode 93.Restore IP Addresses (恢复IP地址)</p>
<p>根据目前刷了这么多题，得出了两个经验，一是只要遇到字符串的子序列或配准问题首先考虑动态规划DP，二是只要遇到需要求出所有可能情况首先考虑用递归。</p>
<p>递归搜索</p>
<p>LeetCode-100 Same Tree（Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value）</p>
<p>遍历</p>
<p>Leetcode 104. Maximum Depth of Binary Tree（Given a binary tree, find its maximum depth）</p>
<p>递归，层序</p>
<p>LeetCode111（The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node）</p>
<p>层序遍历，记录遍历的层数，一旦我们遍历到第一个叶结点，就将当前层数返回</p>
<p>LeetCode126—Word Ladder II</p>
<p>BFS建立邻接表 从后往前搜索</p>
<p>若所有边的长度相等，广度优先搜索算法是最佳解——亦即它找到的第一个解，距离根节点的边数目一定最少</p>
<p>LeetCode127—Word Ladder</p>
<p>bfs</p>
<p>Leetcode128 Longest Consecutive Sequence solution（Given an unsorted array of integers, find the length of the longest consecutive elements sequence）</p>
<p>哈希表，set</p>
<p>LeetCode 129 Sum Root to Leaf Numbers</p>
<p>先序遍历，层序遍历</p>
<p>LeetCode 130 Surrounded Regions（Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.）</p>
<p>搜索</p>
<p>leedcode 134 Gas Station（There are N gas stations along a circular route, where the amount of gas at station i is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1）</p>
<p>贪心，start的后退，end的前进</p>
<p>LeetCode 135 Candy（There are N children standing in a line. Each child is assigned a rating value.You are giving candies to these children subjected to the following requirements:Each child must have at least one candy.Children with a higher rating get more candies than their neighbors.What is the minimum candies you must give?）</p>
<p>两次遍历（前，后）</p>
<p>LeetCode 136 single-number（Given an array of integers, every element appears twice except for one. Find that single one）</p>
<p>异或，哈希</p>
<p>LeetCode 137 single-number-ii（Given an array of integers, every element appears three times except for one. Find that single one）</p>
<p>位运算（妙解），哈希，排序</p>
<p>Leetcode138 Copy List with Random Pointer solution（A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.Return a deep copy of the list.）</p>
<p>插入节点，分离节点</p>
<p>LeetCode139 Word Break（Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words）</p>
<p>dp</p>
<p>leetcode141 Linked List Cycle（Given a linked list, determine if it has a cycle in it.Follow up: Can you solve it without using extra space?）</p>
<p>快慢指针</p>
<p>Leetcode 142 Linked List Cycle (II)（Given a linked list, return the node where the cycle begins. If there is no cycle, return null.Note: Do not modify the linked list.Follow up:Can you solve it without using extra space?）</p>
<p>快慢指针</p>
<p>快慢指针应用：</p>
<p>判断一个链表是否有环</p>
<p>求一个链表是否存在环，如果存在，则求出环的入口结点</p>
<p>求链表是否存在环的变式，如给定两个链表A和B，判断两个链表是否相交，解决方法就是将A链表尾节点指向头结点形成一个环，检测B链表是否存在环，如果存在，则两个链表相交，而检测出来的依赖环入口即为相交的第一个点</p>
<p>求有序链表中求出其中位数，这种问题也是设置快慢指针，当快指针到底链表尾部的时候，慢指针刚好指向链表中间的结点</p>
<p>LeetCode-143. Reorder List（Given a singly linked list L: L 0→L 1→…→L n-1→L n,reorder it to: L 0→L n →L 1→L n-1→L 2→L n-2→…You must do this in-place without altering the nodes’ values.）</p>
<p>快慢指针</p>
<p>LeetCode 144. Binary Tree Preorder Traversal（Given a binary tree, return the preorder traversal of its nodes’ values.Note: Recursive solution is trivial, could you do it iteratively?）</p>
<p>栈，递归</p>
<p>[leetcode]147. Insertion Sort List（Sort a linked list using insertion sort）</p>
<p>新建一个链表,遍历原链表，将每个节点加入新链表正确的位置</p>
<p>Leetcode 149 Max Points on a Line</p>
<p>穷举法，两边循环，找斜率</p>
<p>CV中的hough transform（据说不保证完全正确）</p>
<p>LeetCode 148. Sort List–O(nlogn)时间复杂度和常数空间复杂度给链表排序</p>
<p>归并排序和快慢指针</p>
<p>LeetCode150逆波兰表达式求解（Evaluate Reverse Polish Notation）</p>
<p>用栈</p>
<p>判断两个链表是否相交并找出交点</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-云计算/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-云计算/" itemprop="url">计算机科学与工程-云计算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:45+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>云计算的三层：PAAS（platform），SAAS（software），IAAS（Infrastructure）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-算法/" itemprop="url">计算机科学与工程-算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:45+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<ul>
<li><strong>快排复杂度是多少，并且黑板上手写证明</strong></li>
<li><strong>简述如何“快速选到第n个数”（快速选择，复杂度为O（n））</strong></li>
</ul>
<h1>概念</h1>
<p>算法五个特性： 有穷性、确定性、可行性、输入、输出</p>
<p>算法设计要求：正确性、可读性、健壮性、高效率与低存储量需求。(好的算法)</p>
<p>算法的描述有伪程序、流程图、N-S结构图等。E-R图是实体联系模型，不是程序的描述方式。</p>
<p>设计算法在执行时间时需要考虑：算法选用的规模、问题的规模</p>
<p>时间复杂度：算法的执行时间与原操作<strong>执行次数</strong>之和成正比。时间复杂度有小到大：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2)、O(n</sup>3)。幂次时间复杂度有小到大O(2<sup>n)、O(n!)、O(n</sup>n)</p>
<p>空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析<strong>除输入和程序之外的辅助变量所占额外空间</strong>。</p>
<h1>动态优化</h1>
<h1>搜索</h1>
<p>DFS，BFS，回溯</p>
<h1>查找</h1>
<p>二分，线性查找</p>
<h1>图</h1>
<p>Dijkstra，深度优先，广度优先，拓扑排序，强连通分量，最小生成树，最短路径，最大流</p>
<h1>贪心</h1>
<h1>分治</h1>
<p><a href="https://www.cnblogs.com/hellohacker/p/5827222.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellohacker/p/5827222.html</a></p>
<h1>排序</h1>
<p>插入，选择，冒泡，希尔，快速，归并，堆，计数，桶，基数，外排序</p>
<p><img src="/2019/03/08/计算机科学与工程-算法/1.png" alt="1"></p>
<h1>随机算法</h1>
<h1>摊还分析</h1>
<h1>多线程算法</h1>
<h1>矩阵运算</h1>
<h1>线性规划</h1>
<h1>多项式与快速傅里叶变换</h1>
<h1>数论算法</h1>
<h1>字符串</h1>
<p>模式匹配：KMP算法</p>
<h1>计算几何学</h1>
<h1>NP完全性</h1>
<h1>近似算法</h1>
<h1>大数问题</h1>
<p><a href="https://www.cnblogs.com/2228212230qq/p/7684472.html" target="_blank" rel="noopener">https://www.cnblogs.com/2228212230qq/p/7684472.html</a></p>
<p><a href="https://www.cnblogs.com/ganhang-acm/p/3860361.html" target="_blank" rel="noopener">https://www.cnblogs.com/ganhang-acm/p/3860361.html</a></p>
<p><a href="https://blog.csdn.net/xiang_6/article/details/80659769" target="_blank" rel="noopener">https://blog.csdn.net/xiang_6/article/details/80659769</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-组成原理:体系结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-组成原理:体系结构/" itemprop="url">计算机科学与工程-组成原理/体系结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:45+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>冯·诺依曼体系结构：</p>
<p>计算机处理的数据和指令一律用二进制数标傲世</p>
<p>顺序执行程序</p>
<p>计算机硬件由计算器、控制器、存储器、输入设备和输出设备五大部分组成</p>
<p>数据的机内表示</p>
<p>二进制表示</p>
<p>原码：符号位加上真值的绝对值</p>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
<p>反码：正数的反码是本身，负数的反码在其原码的基础上, 符号位不变，其余各个位取反</p>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
<p>补码：正数的补码就是本身，负数的补码在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1）</p>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<p>定点数与浮点数</p>
<p>定点数是小数点固定的数</p>
<p>浮点数是小数点可以变动的数，类似于十进制中的科学计数法</p>
<p>计算机中通常分为阶码和尾数表示，阶码一般用补码定点整数表示，尾数一般用补码或者原码定点小数表示。</p>
<p>位（Bit）、字节（Byte）、字（Word）</p>
<p>位：电子计算机中最小的数据单位。每一位的状态只能是0或者1</p>
<p>字节：8个二进制位构成1个字节，它是存储空间的基本计量单位。1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。</p>
<p>字：&quot;字&quot;由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，那么，它的1个字就由2个字节构成，字长为16位。字是计算机进行数据处理和运算的单位。</p>
<h1>CPU</h1>
<h2 id="cu"><a class="header-anchor" href="#cu">¶</a>CU</h2>
<h2 id="pu"><a class="header-anchor" href="#pu">¶</a>PU</h2>
<h1>存储器</h1>
<h1>ISA</h1>
<h2 id="汇编"><a class="header-anchor" href="#汇编">¶</a>汇编</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-编译原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-编译原理/" itemprop="url">计算机科学与工程-编译原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:45+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>三型文法的定义</li>
</ul>
<p>0型文法：包括所有文法，产生能够被图灵机识别的语言。无限制短语语法结构</p>
<p>1型文法：生成上下文相关语言。左边符号长度小于等于右边符号长度</p>
<p>2型文法：左边只能有非终结符</p>
<p>3型文法：右边的非终结符只能在一边</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-数据库/" itemprop="url">计算机科学与工程-数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:28+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>异常情况</p>
<p>脏读(Dirty Read)：当一个事务读取另一个事务尚未提交的修改时，产生脏读。</p>
<p>非重复读(Nonrepeatable Read) 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。</p>
<p>幻像读(Phantom Reads) 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。</p>
<p>丢失修改(Lost Update)</p>
<p>第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。</p>
<p>第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。</p>
<p>隔离级别</p>
<p>未提交读(Read Uncommitted)</p>
<p>直译就是&quot;读未提交&quot;，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。</p>
<p>Read Uncommitted允许脏读。</p>
<p>Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。</p>
<p>已提交读(Read Committed)</p>
<p>直译就是&quot;读提交&quot;，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。</p>
<p>Read Commited 不允许脏读，但会出现非重复读。</p>
<p>Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。</p>
<p>可重复读(Repeatable Read)：</p>
<p>直译就是&quot;可以重复读&quot;，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。</p>
<p>Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</p>
<p>Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。</p>
<p>串行读(Serializable)</p>
<p>直译就是&quot;序列化&quot;，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</p>
<p>Serializable 不允许不一致现象的出现。</p>
<p>Serializable 读加共享锁，写加排他锁，读写互斥。</p>
<p>海量数据怎么存储</p>
<p>索引</p>
<p>数据库创建索引能够大大提高系统的性能。</p>
<p>第一，通过创建唯一性的索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>第二，可以大大加快数据的检索速度，这也使创建索引的最主要的原因。</p>
<p>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>第四，在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。</p>
<p>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>增加索引也有许多不利的方面。</p>
<p>第一，创建索引和维护索引需要消耗时间，这种时间随着数量的增加而增加</p>
<p>第二，索引需要占物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要额空间就会更大。</p>
<p>第三，当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<p>应该对如下的列建立索引</p>
<p>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</p>
<p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</p>
<p>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。</p>
<p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
<p>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</p>
<p>有些列不应该创建索引</p>
<p>在查询中很少使用或者作为参考的列不应该创建索引。</p>
<p>对于那些只有很少数据值的列也不应该增加索引（比如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度）。</p>
<p>对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的。</p>
<p>创建索引的方法：直接创建和间接创建（在表中定义主键约束或者唯一性约束时，同时也创建了索引）。</p>
<p>索引的特征：</p>
<p>唯一性索引和复合索引。唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。复合索引就是一个索引创建在两个列或者多个列上。可以减少一在一个表中所创建的索引数量。</p>
<p>高维空间相交的线映射在低维空间，是否一定相交（直接取部分坐标，线性映射，必然相交）</p>
<p>生产者消费者模型</p>
<p>几个范式</p>
<p>锁：</p>
<p>共享锁(S锁)：用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。</p>
<p>更新锁(U锁)：用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。</p>
<p>独占锁(X锁，也叫排他锁)：一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。</p>
<p>图数据库</p>
<p><a href="http://blog.csdn.net/hzw05103020/article/details/51288992" target="_blank" rel="noopener">http://blog.csdn.net/hzw05103020/article/details/51288992</a></p>
<p>也可能存在这样的调度，它们产生的结果相同，但却不是冲突等价的。考虑两个调度S和S’，其中参与两个调度的事务集是相同的。若调度S和S’满足下面三个条件，则称S和S’是视图等价的。</p>
<p>⑴　对于每个数据项Q，若事务Ti在调度S中读取了Q的初始值，那么Ti在调度S’中也必须读取Q的初始值；</p>
<p>⑵　对于每个数据项Q，若事务Ti在调度S中执行了read(Q)并且读取的值是由Tj产生的(write(Q))，则Ti在调度S’中读取的值也必须是由Tj产生的(write(Q))；</p>
<p>⑶　对于每个数据项Q，若在调度S中有事务执行了最后的写操作write(Q)，则在调度S’中该事务也必须执行最后的写操作write(Q)。</p>
<p>在视图等价的三个条件中，前两个条件保证了两个调度中的每个事务都读取了相同的值，从而才能进行相同的计算。第三个条件和前两个条件一起保证了两个调度能够得到相同的最终结果。</p>
<p><a href="http://www.educity.cn/zk/sjkyl/201306141646051747.htm" target="_blank" rel="noopener">http://www.educity.cn/zk/sjkyl/201306141646051747.htm</a></p>
<p><a href="http://www.educity.cn/zk/sjkyl/201306141542141835.htm" target="_blank" rel="noopener">http://www.educity.cn/zk/sjkyl/201306141542141835.htm</a></p>
<p><a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">https://www.zhihu.com/question/24696366</a></p>
<p>OLTP，OLAP</p>
<p>产品：</p>
<p>Oracle、MySQL、HBase，Cassandra，MongeDB，MariaDB，PostgreSQL，NoSQL，Redis</p>
<p>RDB：SQL</p>
<p>NoSQL：Redis</p>
<h1>概念</h1>
<h2 id="典型应用"><a class="header-anchor" href="#典型应用">¶</a>典型应用</h2>
<p>Online Transaction Processing (OLTP)</p>
<p>Online analytical processing (OLAP) and Data Warehousing</p>
<p>数据挖掘</p>
<p>大数据（Volume，Velocity，Variety）</p>
<h2 id="模型"><a class="header-anchor" href="#模型">¶</a>模型</h2>
<p>网状数据模型Network data model</p>
<ul>
<li>Integrated Data Store (IDS), by Charles Bachman, early 1960s</li>
</ul>
<p>层次数据模型Hierarchical data model</p>
<ul>
<li>Information Management System (IMS), by IBM, late 1960s</li>
</ul>
<p>关系数据模型Relational Data Model</p>
<ul>
<li>Codd, E.F. (1970). “A Relational Model of Data for Large Shared Data Banks”. Communications of the ACM 13 (6): 377–387.</li>
</ul>
<p>SQL语言 Structured Query Language</p>
<ul>
<li>System R, by IBM, started in 1974</li>
</ul>
<p>面向对象关系数据库 Object-Relational DBMS</p>
<ul>
<li>Stonebraker, Michael with Moore, Dorothy. ObjectRelational DBMSs: The Next Great Wave. 1996</li>
</ul>
<h2 id="dbms的结构"><a class="header-anchor" href="#dbms的结构">¶</a>DBMS的结构</h2>
<p><img src="/2019/03/08/计算机科学与工程-数据库/image-20190814191053543.png" alt="image-20190814191053543"></p>
<p>views describe how users see the data</p>
<p>Conceptual schema defines logical structure（存储了哪些关系relations）</p>
<p>Physical schema specifies physical structure（How the “logical” relations are physically stored on external storage such as disk）</p>
<p><img src="/2019/03/08/计算机科学与工程-数据库/image-20190814191333257.png" alt="image-20190814191333257"></p>
<h1>ER模型</h1>
<p>实体entity</p>
<p>关系relationship</p>
<h2 id="关系模型"><a class="header-anchor" href="#关系模型">¶</a>关系模型</h2>
<p>关系数据模型是目前最广泛使用的模型</p>
<p>关系relation：一个表格table（有行rows和列columns）</p>
<p>schema：用来描述列（名字，类型，限制等）</p>
<h1>sql</h1>
<h1>存储</h1>
<h2 id="索引"><a class="header-anchor" href="#索引">¶</a>索引</h2>
<p>哈希索引，B+树索引</p>
<h2 id="和文件对比"><a class="header-anchor" href="#和文件对比">¶</a>和文件对比</h2>
<p>Good data modeling</p>
<ul>
<li>Data Independence</li>
<li>Data Integrity and Security</li>
</ul>
<p>Simple and efficient ad-hoc queries，减少了应用开发时间</p>
<p>Concurrency control</p>
<p>Crash recovery</p>
<h1>查询优化</h1>
<p>连接，排序</p>
<h1>事务处理</h1>
<p>ACID，并发处理</p>
<p>事务的特性ACID</p>
<p>A，atomacity：原子性，事务必须是原子工作单元，对于数据的执行要不是全部执行，要不都不执行。如果只执行一个子集，可能会破坏事务的总体目标。</p>
<p>C，consistency：一致性。事务将数据库从一种一致状态变为下一种一致状态（各种约束不被破坏）</p>
<p>I，isolation：隔离性。由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。</p>
<p>D，durability，持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</p>
<h1>崩溃恢复</h1>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-计算机网络/" itemprop="url">计算机科学与工程-计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:40:01+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a></p>
<p>物理层。波分复用、频分复用等</p>
<p>数据链路层。以太网及MAC等。</p>
<p>网络层。IP、BGP、OSPF、RIP。包括数据报文格式等。</p>
<p>TCP UDP区别</p>
<p>在实际中的应用：TCP要经过三次握手，消耗的资源会比较多，通常只有当我们确保能够传输到的时候才会用到TCP协议，比如说收发邮件。而UDP就比较方便，消耗的资源也比较少，但是不可靠，可能出现丢包，平时看视频聊天什么的用UDP协议，因为丢个一辆帧不会有太大影响。端口</p>
<p>链路层网络层传输层的作用</p>
<p>http协议，https</p>
<p>HTTP的特性</p>
<p>：HTTP构建于TCP/IP协议之上，默认端口号为80</p>
<p>HTTP是无连接状态的</p>
<p>http和https的区别</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>HTTPS的优点</p>
<p>1、SEO方面</p>
<p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
<p>2、安全性</p>
<p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<p>（1）、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>（2）、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
<p>（3）、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p>HTTPS的缺点</p>
<p>虽然说HTTPS有很大的优势，但其相对来说，还是有些不足之处的，具体来说，有以下2点：</p>
<p>1、SEO方面</p>
<p>据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。</p>
<p>而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</p>
<p>最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
<p>2、经济方面</p>
<p>（1）、SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
<p>（2）、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</p>
<p>（3）、HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。</p>
<p>（4）、HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。</p>
<p>（5）、HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。</p>
<p>HTTP报文</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>请求报文：HTTP协议是以ASCII码传输，建立在TCP/IP协议之上的应用层规范。规范把HTTP请求分为三个部分：状态行、请求头、消息主体</p>
<p>一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。</p>
<p><method> <request-url> <version><br>
<headers></headers></version></request-url></method></p>
<entity-body>
GET：信息获取，安全的（不修改，不产生副作用）、幂等的（对同一个URL的多个请求应该返回同样的结果）
<p>GET /books/?sex=man&amp;name=Professional HTTP/1.1<br>
Host: <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a><br>
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>
Gecko/20050225 Firefox/1.0.1<br>
Connection: Keep-Alive<br>
POST表示可能修改服务器上的资源的请求</p>
<p>POST / HTTP/1.1<br>
Host: <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a><br>
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>
Gecko/20050225 Firefox/1.0.1<br>
Content-Type: application/x-www-form-urlencoded<br>
Content-Length: 40<br>
Connection: Keep-Alive</p>
<p>sex=man&amp;name=Professional<br>
GET提交的数据收到URL长度的限制，HTTP协议规范设有对URL长度进行限制。这个限制是特定的浏览器及服务器对于它的限制</p>
<p>POST是没有大小限制的，HTTP协议规范也没有进行大小限制。但是出于安全考虑，服务器软件实现的时候会做一定的限制</p>
<p>GET和POST的数据是一样的，知识位置不同，一个在URL里面，一个在HTTP包的包体里</p>
<p>POST提交的数据必须在body部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。客户端可以自己决定消息主题的格式。但是服务端一般根据请求头中的Content-Type字段来获知请求中的消息是用什么编码方式</p>
<p>application/x-www-form-urlencoded<br>
最常见的POST数据提交方式，浏览器原生的<form>表单。如果不设置enctype属性，最终就会以application/x-www-form-urlencoded 方式提交数据。<br>
multipart/form-data<br>
我们使用表单上传文件时，必须让 <form> 表单的 enctype 等于 multipart/form-data<br>
首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。<br>
Content-Type 里指明了数据是以 multipart/form-data 来编码<br>
每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）<br>
如果传输的是文件，还要包含文件名和文件类型信息。<br>
application/json，text/xml，乃至 application/x-protobuf 这种二进制格式，只要服务器可以根据 Content-Type和 Content-Encoding 正确地解析出请求，都是没有问题的</form></form></p>
<p>相应报文</p>
<p>状态行</p>
<p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<p>状态代码：</p>
<p>1xx：指示信息–表示请求已接收，继续处理</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>消息报头：说明客户端要使用的一些附加信息</p>
<p>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>
<p>空行：消息报头后面的空行是必须的</p>
<p>响应正文：服务器返回给客户端的文本信息</p>
<p>会话跟踪：浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是无状态的协议。不能保存客户的信息，即一次响应完成之后连接就断开了，下一次请求需要重新连接。会话跟踪技术判断两个连接是否是同一个用户。</p>
<p>URL重写：在URL末尾添加一个附加数据，标识该会话，把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。</p>
<p>隐藏表单域：将会话ID添加到HTML表单元素中</p>
<p>Cookie：保存在客户端，web服务器发送给客户端的一小段信息，客户端读取信息发送到服务器端，进而进行用户识别</p>
<p>保存自客户端内存：临时，浏览器关闭就小时</p>
<p>保存在客户机磁盘上：永久</p>
<p>可以被禁止</p>
<p>Session：保存在服务端，可以保存在集群、数据库、文件中。session唯一标识每一个用户。session实现依赖于cookie，如果cookie禁用，那么session也将失效。</p>
<p>主要特点：</p>
<p>简单快速：仅仅包括请求头、方法和参数</p>
<p>灵活：允许传输任意类型对象，COntent-Type加以标记</p>
<p>无连接：限制每次连接只处理一个请求，处理完客户的请求以并收到客户的应答以后，断开连接。采用这种方式节省传输时间</p>
<p>无状态：无状态，协议对于事务没有记忆能力，这可能导致每次传送数据量增大，但是应答比较快</p>
<p>url：</p>
<p>协议</p>
<p>域名</p>
<p>端口</p>
<p>虚拟目录</p>
<p>文件名</p>
<p>锚部分</p>
<p>参数部分</p>
<p>HTTP工作原理：HTTP协议定义了Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</p>
<p>HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>客户端连接到Web服务器（客户度那通常是浏览器，与Web服务器的HTTP端口建立一个TCP套接字连接）</p>
<p>——&gt;发送HTTP请求（通过TCP套接字，客户端向Web服务器发送个文本的请求报文，由请求行、请求头部、空行和请求数据4部分构成）</p>
<p>——&gt;Web服务器解析请求，定位请求资源，将资源副本写到TCP套接字，由客户端读取。一个响应由状态行，响应头部、空行和响应数据4部分组成。</p>
<p>——&gt;释放TCP连接，如果connection为close模式，服务器主动关闭TCP连接，客户端被动关闭连接，释放请求。</p>
<p>——&gt;客户端解析状态行，查看请求的状态代码，解析每一个响应头，响应头告知以下若干字节的HTML文档和文档的字符集，客户端浏览器读取相应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口显示。</p>
<p>浏览器——&gt;DNS解析请求</p>
<p>浏览器——&gt;服务器建立TCP连接</p>
<p>读取请求报文作为TCP三次握手第三个报文数据——&gt;发给服务器</p>
<p>服务器——&gt;客户端（HTML文本）</p>
<p>释放TCP</p>
<p>浏览器显示HTM:</p>
<p>get请求：以?分割URL和传输数据，多个参数用&amp;连接；</p>
<p>英文字母/数字，原样发送</p>
<p>如果是空格，转换为+</p>
<p>如果是中文/其他字符，则直接把字符串用BASE64加密</p>
<p>GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p>
<p>大小限制：HTTP协议对传输数据大小，URL长度没有限制</p>
<p>但是GET——&gt;浏览器和服务器对URL长度有限制。</p>
<p>POST理论上不受限制但是服务器会规定数据大小</p>
<p>TCP特性</p>
<p>TCP面向连接、可靠的字节流服务</p>
<p>TCP连接中，仅有两方进行彼此通信，广播和多播不能用于TCP</p>
<p>TCP使用校验和、确认和重传机制保证可靠传输</p>
<p>TCP给数据分节进行排序，并使用累计确认保证数据顺序的不变和非重复</p>
<p>TCP使用滑动窗口机制来实现流量控制，通过改变窗口大小进行拥塞控制</p>
<p>TCP不能保证数据一定会被对方接收，但是它所能提供的数据是可靠递送或者故障的可靠通道</p>
<p>三次握手</p>
<p>建立一个TCP连接时，需要客户端和服务器总共发送三个包</p>
<p>连接服务器指定端口</p>
<p>建立TCP连接</p>
<p>同步连接双方的序列号和确认好</p>
<p>交换TCP窗口大小</p>
<p>第一次握手：SYN=1，seq=x：</p>
<p>客户端发送一个TCP的SYN标志位置1的包，指明客户端打算连接的服务器的端口</p>
<p>初始序号x保存在包头的序列号字段里</p>
<p>发送完毕后面，客户端进入SYN_SENT状态</p>
<p>第二次握手：(SYN=1, ACK=1, seq=y, ACKnum=x+1)</p>
<p>服务器发回确认包（ACK）应答</p>
<p>选择自己的ISN序号，放到Seq域里</p>
<p>确认序号设置为客户端ISN序号加1：X+1</p>
<p>服务端进入SYN_RCVD</p>
<p>第三次握手：(ACK=1，ACKnum=y+1)</p>
<p>客户端再次发送确认包ACK</p>
<p>SYN标志位为0</p>
<p>ACK标志位为1</p>
<p>确定字段为服务器发来ACK的序号字段+1</p>
<p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p>
<p>四次挥手</p>
<p>第一次挥手(FIN=1，seq=x)</p>
<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>
<p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p>
<p>第二次挥手(ACK=1，ACKnum=x+1)</p>
<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>
<p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2状态，等待服务器端关闭连接。</p>
<p>第三次挥手(FIN=1，seq=y)</p>
<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p>
<p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p>
<p>第四次挥手(ACK=1，ACKnum=y+1)</p>
<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p>
<p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态</p>
<p>SYN攻击：</p>
<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>
<p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
<p>如何检测 SYN 攻击？</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<p>如何防御 SYN 攻击？</p>
<p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p>
<p>缩短超时（SYN Timeout）时间</p>
<p>增加最大半连接数</p>
<p>过滤网关防护</p>
<p>SYN cookies技术</p>
<p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。</p>
<p>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p>
<p>IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836 IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837 IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1</p>
<p>第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;</p>
<p>第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;</p>
<p>第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。</p>
<p>图解： 一个三次握手的过程（图1，图2）</p>
<p>（图1） （图2）</p>
<p>第一次握手的标志位（图3） 我们可以看到标志位里面只有个同步位，也就是在做请求(SYN) （图3） 第二次握手的标志位（图4） 我们可以看到标志位里面有个确认位和同步位，也就是在做应答(SYN + ACK) （图4） 第三次握手的标志位（图5） 我们可以看到标志位里面只有个确认位，也就是再做再次确认(ACK) （图5） 一个完整的三次握手也就是 请求—应答—再次确认</p>
<p>UDP</p>
<p>UDP特性：</p>
<p>缺乏可靠性：UDP本身不提供确认、序列号、超时重传等机制。因此UDP不保证数据报能够到达、不保证数据报的先后顺序、不保证每个数据报只到达一次</p>
<p>UDP数据报是有长度的，每个UDP数据报如果正确到达目的地，数据报的长度会一起传递给接收方，但是TCP是一个字节流协议，没有任何的边界记录</p>
<p>UDP是无连接的。UDP客户和服务器之间不必存在长期的关系，不需要握手创建连接</p>
<p>UDP支持多播和广播</p>
<p>IP协议</p>
<p>IP协议位于TCP/IP协议的第三层——网络层。与传输层协议相比，网络层的责任是提供点到点(hop by hop)服务，而传输层（TCP/UDP）提供端到端的服务</p>
<p>IP地址分类：A、B、C、D</p>
<p>广播：</p>
<p>四种广播地址：</p>
<p>受限广播：255.255.255.255。该地址用于主机配置过程中IP数据报的目的地址，在任何情况下，router不转发目的地址为255.255.255.255的数据报，这样的数据报仅出现在本地网络中。</p>
<p>指向网络的广播：</p>
<h1>应用层</h1>
<p>HTTP，FTP，IMAP/POP3/SMTP，DNS</p>
<p>P2P</p>
<h1>传输层</h1>
<p>TCP，UDP</p>
<h1>网络层</h1>
<p>交换机，路由器，路由表</p>
<p>私有网络，子网</p>
<p>反向代理</p>
<p>NAT网关</p>
<h1>链路层</h1>
<p>LTE，WIFI，蓝牙，IPv4/6，NFV，VLAN，IPQoS</p>
<p>PPP</p>
<p>SDN（OpenFlow）</p>
<p>DHCP</p>
<p>ICMP</p>
<p><img src="/2019/03/08/计算机科学与工程-计算机网络/1.png" alt="img"></p>
<p>协议图<a href="https://blog.csdn.net/china_jeffery/article/details/79195819" target="_blank" rel="noopener">https://blog.csdn.net/china_jeffery/article/details/79195819</a></p>
<p>交换机配置，路由器配置</p>
<p>云api密钥，SSH密钥，安全组，IPsec，SSH，SSL，防火墙</p>
<p>弹性公网IP，多IP服务器</p>
<p>包转发率(PPS)</p>
<p>CDN</p>
<p>管理工具：wireshark</p>
<p>QoS配置，ACL规则</p>
<p>边界网关协议（BGP）</p>
<p>ACL访问控制策略</p>
<p>ISP</p>
</entity-body>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/计算机科学与工程-操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenxr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenxr's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/计算机科学与工程-操作系统/" itemprop="url">计算机科学与工程-操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:39:39+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>死锁</p>
<p>多个进程因循环等待资源而造成无法执行的现象，造成系统资源的极大浪费，无法释放</p>
<p>死锁原因（AB互相索取资源）</p>
<p>死锁条件（四项）</p>
<p>互斥使用：进程对资源进行排他性使用，一段时间内某资源只由一个进程占用。如果还有其他进程请求资源，则请求者只能等待，直到占用资源的进程用毕释放</p>
<p>不可抢占</p>
<p>请求和保持：该进程已经保持了至少一个资源，但是提出新的请求，而请求资源已经被占用，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p>循环等待：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
<p>处理器管理。包括进程控制、进程互斥等。</p>
<p>存储管理。包括分区存储、页式存储等。</p>
<p>文件管理。包括文件目录、文件系统的实现等。</p>
<p>操作系统线程跟进程的区别等（操作系统的问题比较爱问）</p>
<p>多任务</p>
<p>多道程序：CPU资源比较珍贵，为了让CPU得到更好的利用，把暂时无需使用的CPU用于其他正在等待CPU资源的程序，称为多道程序。缺点是不分轻重缓急</p>
<p>分是系统：改进躲到程序，使得每个程序运行一段时间就主动让出CPU资源</p>
<p>多任务系统：操作系统从最底层接管了所有的硬件资源，所有应用程序在操作系统之上以进程的方式运行，每个进程拥有自己独立的地址空间，相互隔离。CPU统一由操作系统进行分配</p>
<p>进程</p>
<p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>
<p>第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。</p>
<p>文本区域存储处理器执行的代码；</p>
<p>数据区域存储变量和进程执行期间使用的动态分配的内存；</p>
<p>堆栈区域存储着活动过程调用的指令和本地变量。</p>
<p>第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p>
<p>基本状态：</p>
<p>等待态：等待某个事件的完成；</p>
<p>就绪态：等待系统分配处理器以便运行；</p>
<p>运行态：占有处理器正在运行。</p>
<p>状态转换：</p>
<p>运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。</p>
<p>等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。</p>
<p>运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</p>
<p>就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态</p>
<p>进程调度</p>
<p>调度种类：高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</p>
<p>高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；</p>
<p>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</p>
<p>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</p>
<p>调度算法：</p>
<p>FIFO或First Come, First Served (FCFS)，调度的顺序就是任务到达就绪队列的顺序。</p>
<p>Shortest Job First (SJF)，最短的作业(CPU区间长度最小)最先调度。SJF可以保证最小的平均等待时间。</p>
<p>优先权调度，每个任务关联一个优先权，调度优先权最高的任务。注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</p>
<p>Round-Robin(RR)，设置一个时间片，按时间片来轮转调度（“轮叫”算法），优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</p>
<p>多级队列调度：</p>
<p>按照一定的规则建立多个进程队列</p>
<p>不同的队列有固定的优先级（高优先级有抢占权）</p>
<p>不同的队列可以给不同的时间片和采用不同的调度方法</p>
<p>多级反馈队列：在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。 可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。</p>
<p>本地进程通信：</p>
<p>消息传递（管道、FIFO、消息队列）</p>
<p>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</p>
<p>共享内存（匿名的和具名的）</p>
<p>远程过程调用（Solaris门和Sun RPC）</p>
<p>线程</p>
<p>多进程解决了前面提到的多任务问题。然而很多时候不同的程序需要共享同样的资源（文件，信号量等），如果全都使用进程的话会导致切换的成本很高，造成 CPU 资源的浪费。于是就出现了线程的概念。</p>
<p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</p>
<p>轻型实体 线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p>
<p>在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p>
<p>可并发执行。 在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</p>
<p>共享进程资源。在同一进程中的各个线程，都可以共享该进程所拥有的资源</p>
<p>所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；</p>
<p>问进程所拥有的已打开文件、定时器、信号量等。线程之间互相通信不必调用内核。</p>
<p>线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<p>本地进程间通信的方式：</p>
<p>消息传递（管道、FIFO、消息队列）</p>
<p>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</p>
<p>共享内存（匿名的和具名的）</p>
<p>远程过程调用（Solaris门和Sun RPC）</p>
<p>进程和线程的区别</p>
<p>a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p>
<p>b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
<p>c.调度和切换：线程上下文切换比进程上下文切换要快得多。</p>
<p>d.在多线程OS中，进程不是一个可执行的实体</p>
<h1>基础</h1>
<h2 id="os提供的服务"><a class="header-anchor" href="#os提供的服务">¶</a>os提供的服务</h2>
<h2 id="多道程序"><a class="header-anchor" href="#多道程序">¶</a>多道程序</h2>
<p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。与之相对应的是单道程序，即在计算机内存中只允许一个的程序运行。对于一个单CPU系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU上运行的程序只有一个</p>
<h2 id="分时系统"><a class="header-anchor" href="#分时系统">¶</a>分时系统</h2>
<p><a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3067636" target="_blank" rel="noopener">分时操作系统</a> (time-sharing system)，“分时”的含义：分时是指多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源。<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3067636" target="_blank" rel="noopener">分时操作系统</a>是指在一台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151" target="_blank" rel="noopener">主机</a>上连接多个带有显示器和键盘的<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/1903878" target="_blank" rel="noopener">终端</a>，同时允许多个用户通过主机的终端，以交互方式使用计算机，共享主机中的资源。<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3067636" target="_blank" rel="noopener">分时操作系统</a>是一个多用户交互式操作系统。<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3067636" target="_blank" rel="noopener">分时操作系统</a>，主要分为三类：单道分时操作系统，多道分时操作系统，具有前台和后台的分时操作系统。<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3067636" target="_blank" rel="noopener">分时操作系统</a>将CPU的时间划分成若干个片段，称为<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87/6525414" target="_blank" rel="noopener">时间片</a>。操作系统以<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87/6525414" target="_blank" rel="noopener">时间片</a>为单位，轮流为每个<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF" target="_blank" rel="noopener">终端</a>用户服务。</p>
<h2 id="微内核"><a class="header-anchor" href="#微内核">¶</a>微内核</h2>
<h1>系统调用</h1>
<h2 id="中断"><a class="header-anchor" href="#中断">¶</a>中断</h2>
<p>中断（interrupt）是是一种硬件机制，指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件（处理器外部的一个事件或者处理器内部的一个事件，内部的中断，比如说定时器中断，当定时器定时到的时候，就会产生一个中断来告诉处理器，这时候处理器可以做出相应的动作；外部中断，比如说某个管脚的电平发生了变化，这时候就会产生一个中断来告诉处理器），使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。</p>
<p>因此中断是一种处理器与外设进行通信的机制，用于“通知”处理器外部有“重要事件发生”，一般情况下，中断需要被处理器响应。它是计算机可以更好更快利用有限的系统资源解决系统<a href="https://www.baidu.com/s?wd=%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">响应速度</a>和运行效率,实现实时响应,系统调度的一种控制技术。中断的意义还在于应用程序不必关心中断的发生与处理，以及中断服务程序不必关心应用程序的执行状态。</p>
<p>中断是由外部事件导致并且它发生的时间是不可预测的，这一点和陷阱不同，中断发生完全是&quot;异步&quot;的，根本无法预测到此类中断会在什么时候发生。因此，<a href="https://www.baidu.com/s?wd=CPU&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">CPU</a>(或者软件)对于此类外部中断完全是&quot;被动&quot;的。在有些情况下，尽管产生了中断源和发出了中断请求，但CPU内部的处理器状态字PSW的中断允许位已被清除，从而不允许CPU响应中断。这种情况称为禁止中断。CPU禁止中断后只有等到PSW的中断允许位被重新设置后才能接收中断。禁止中断也称为关中断，PSW的中断允许位的设置也被称为开中断。开中断和关中断是为了保证某段程序执行的原子性。还有一个比较常用的概念是中断屏蔽。中断屏蔽是指在中断请求产生之后，系统有选择地封锁一部分中断而允许另一部分中断仍能得到响应。不过，有些中断请求是不能屏蔽甚至不能禁止的，也就是说，这些中断具有最高优先级，只要这些中断请求一旦提出，CPU必须立即响应。例如，电源掉电事件所引起的中断就是不可禁止和不可屏蔽的。</p>
<p>外部事件主要是指时钟中断，硬件中断等。由于CPU一次只能运行一条指令，所以在一个时刻只能有一个程序运行，但我们感觉在我们的计算机中明明可以同时运行很多程序，这是由于CPU在多个进程之间快速切换所导致的伪并行。如果某一个程序运行了足够长用完了分配给它的时间片，CPU决定切换到另一个进程运行，就会产生一个时钟中断，切换到下一个进程运行。</p>
<p>硬件中断顾名思义就是由硬件引起的中断，比如一个程序需要用户输入一个数据，但用户一直没有输入，操作系统决定是一直等待用户输入还是转而运行别的进程，一般情况是转而运行别的进程，如果用户的输入到来了，那么键盘驱动器会产生一个中断通知操作系统，操作系统保存正在运行的程序的状态，从而切换到原来的进程处理到来的数据。</p>
<p>所以中断发生是随机的且主要作用是完成进程间切换，从而支持CPU和设备之间的并行。</p>
<p>中断和异常的另一个重要差别是，CPU处理中断的过程中会屏蔽中断，不接受新的中断直到此次中断处理结束。而陷阱的发生并不屏蔽中断，可以接受新的中断。</p>
<p>硬中断：通过处理器中断信号线产生的中断</p>
<p>软中断：通过非法指令或特殊指令触发的中断</p>
<p>计算机的中断系统能够加强CPU对多任务事件的处理能力。中断机制是现代计算机系统中的基础设施之一，它在系统中起着通信网络作用，以协调系统对各种外部事件的响应和处理。中断是实现多道程序设计的必要条件。中断是CPU对系统发生的某个事件作出的一种反应。引起中断的事件称为中断源。中断源向CPU提出处理的请求称为中断请求。发生中断时被打断程序的暂停点成为断点。CPU暂停现行程序而转为响应中断请求的过程称为中断响应。处理中断源的程序称为中断处理程序。CPU执行有关的中断处理程序称为中断处理。而返回断点的过程称为中断返回。中断的实现实行软件和硬件综合完成，硬件部分叫做硬件装置，软件部分成为软件处理程序。</p>
<p>根据中断源产生的条件，可把中断分为外中断和内中断。外中断是指来自处理器和内存外部的中断，包括I／0设备发出的I／O中断、外部信号中断(例如用户键人ESC键)。各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。外中断在狭义上一般被称为中断。</p>
<p>内中断主要指在处理器和内存内部产生的中断。内中断一般称为陷阱(trap)或异常。它包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等都是陷阱的例子。</p>
<p>为了按中断源的轻重缓急处理响应中断，操作系统为不同的中断赋予不同的优先级。例如在UNIX系统中，外中断和陷阱的优先级共分为8级。为了禁止中断或屏蔽中断，CPU的处理器状态字PSW中也设有相应的优先级。如果中断源的优先级高于PSW的优先级，则CPU响应该中断源的请求；反之，CPU屏蔽该中断源的中断请求。</p>
<p>各中断源的优先级在系统设计时给定，在系统运行时是固定的。而处理器的优先级则根据执行情况由系统程序动态设定。</p>
<h2 id="陷阱"><a class="header-anchor" href="#陷阱">¶</a>陷阱</h2>
<p>计算机有两种运行模式：用户态， 内核态。 其中操作系统运行在内核态，在内核态中，操作系统具有对所有硬件的完全访问权限，可以使机器运行任何指令；相反，用户程序运行在用户态，在用户态下，软件只能使用少数指令，它们并不具备直接访问硬件的权限。这就出现了问题，假如软件需要访问硬件或者需要调用内核中的函数该怎么办呢，这就是陷阱的作用了。陷阱指令可以使执行流程从用户态陷入内核（这也就是为什么叫做陷阱，而不是捕猎的陷阱）并把控制权转移给操作系统，使得用户程序可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。</p>
<p>陷阱是程序有意产生的。</p>
<p>操作系统有很多系统调用接口供用程序调用。陷阱的发生时间是固定的，比如第一次用视频软件时，在加载视频时软件会向操作系统发送陷阱指令，第二次播放时，软件仍然会在同样的时刻发送陷阱指令。这一点是和中断的明显的差别之一。陷阱通常由处理器正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。</p>
<h2 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h2>
<p>异常就是程序执行过程中的异常行为。比如除零异常，缓冲区溢出异常等。不同的操作系统定义了不同种类和数量的异常并且每个异常都有一个唯一的异常号，异常会扰乱程序的正常执行流程，所以异常是在CPU执行指令时本身出现的问题，比如除数为零而出现的除零异常。异常的产生表示程序设计不合理，所以在编程的时候要尽量避免异常的产生。</p>
<h2 id="系统调用"><a class="header-anchor" href="#系统调用">¶</a>系统调用</h2>
<p>在Unix/Linux系统中，系统调用像普通C函数调用那样出现在C程序中。但是一般的函数调用序列并不能把进程的状态从用户态变为核心态，而系统调用却可以做到。</p>
<p>C语言编译程序利用一个预先确定的函数库（一般称为C库），其中有各系统调用的名字。C库中的函数都专门使用一条指令，把进程的运行状态改为核心态。Linux的系统调用是通过中断指令“INT0x80”实现的。</p>
<p>每个系统调用都有惟一的号码，称作系统调用号。所有的系统调用都集中在系统调用入口表中统一管理。</p>
<p>系统调用入口表是一个函数指针数组，以系统调用号为下标在该数组中找到相应的函数指针，进而就能确定用户使用的是哪一个系统调用。不同系统中系统调用的个数是不同的，目前Linux系统中共定义了221个系统调用。</p>
<p>另外，系统调用表中还留有一些余项，可供用户自行添加。</p>
<p>当CPU执行到中断指令“INT0x80”时，硬件就做出一系列响应，其动作与上述的中断响应相同。CPU穿过陷阱门，从用户空间进入系统空间。相应地，进程的上下文从用户堆栈切换到系统堆栈。</p>
<p>接着运行内核函数system_call（）。首先，进一步保存各寄存器的内容；接着调用syscall_trace()，以系统调用号为下标检索系统调用入口表sys_call_table，从中找到相应的函数；然后转去执行该函数，完成具体的服务。</p>
<p>执行完服务程序，核心检查是否发生错误，并作相应处理。如果本进程收到信号，则对信号作相应处理。最后进程从系统空间返回到用户空间。</p>
<h1>进程</h1>
<p>进程间通信</p>
<h1>存储</h1>
<p>存储系统，虚拟内存</p>
<h1>文件系统</h1>
<p>文件管理系统，文件管理</p>
<h1>IO</h1>
<p>内存IO访问，DMA</p>
<p>primitives原语</p>
<p>ioctl</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chenxr</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenxr</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
